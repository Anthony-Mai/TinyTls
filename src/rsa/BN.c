/******************************************************************************
*
* Copyright © 2014-2019 Anthony Mai Mai_Anthony@hotmail.com. All Rights Reserved.
*
* This file is a part of the software package TinyTls, originally known as TinySsl.
* This software is written by Anthony Mai and is provided under the terms and
* conditions of the GNU General Public License Version 3.0 (GPL V3.0). For the
* specific GPL V3.0 license terms please refer to:
*         https://www.gnu.org/licenses/gpl.html.
*
* This Copyright Notices contained in this code. are NOT to be removed or modified.
* If this package is used in a product, Anthony Mai should be given attribution as
* the author of the parts of the library used. This can be in the form of a textual
* message at program startup or in documentation provided with the package.
*
* This library is free for commercial and non-commercial use as long as the
* following conditions are aheared to. The following conditions apply to
* all code found in this distribution:
*
* 1. Redistributions of source code must retain the copyright notice, this
*    list of conditions and the following disclaimer.
*
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* 3. All advertising materials mentioning features or use of this software
*    must display the following acknowledgement:
*
*    "This product contains software written by Anthony Mai (Mai_Anthony@hotmail.com)
*     The original source code can obtained from such and such internet sites or by
*     contacting the author directly."
*
* 4. This software may or may not contain patented technology owned by a third party.
*    Obtaining a copy of this software, with or without explicit authorization from
*    the author, does NOT imply that applicable patents have been licensed. It is up
*    to you to make sure that utilization of this software package does not infringe
*    on any third party's patents or other intellectual proerty rights.
*
* THIS SOFTWARE IS PROVIDED BY ANTHONY MAI "AS IS". ANY EXPRESS OR IMPLIED WARRANTIES,
* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* The license and distribution terms for any publically available version or derivative
* of this code cannot be changed.  i.e. this code cannot simply be copied and put under
* another distribution license [including the GNU Public License.]
*
******************************************************************************/

/******************************************************************************
*
*  File Name:       BN.c
*
*  Description:     RSA key generation prime number search data file
*                   and RSA encryption and decryption implementation.
*
*
*  Programmers:     Anthony Mai (am) mai_anthony@hotmail.com
*
*  History:         6/17/2014 Initial creation
*
*  Notes:           This file uses 4 spaces indents
*
******************************************************************************/

#include <stdio.h>
#include <assert.h>
#include <stdint.h>

#include "BN.h"


// Using some Hoffman encoding to save code space.
#define NODE_NEXT   ((uint)-1)
#define NODE_END    0
#define PRIME_CYCLE (2*3*5*7*11*13)


typedef struct STREE
{
    uint    N0;
    uint    N1;
    uint    val;
} STREE;


const STREE gT[61] =
{
    { 1,  2, NODE_NEXT},    //0

    { 3,  4, NODE_NEXT},    //1  0
    { 5,  6, NODE_NEXT},    //2  1

    { 1,  2,    1 },        //3  00
    { 1,  2,    2 },        //4  01
    { 1,  2,    3 },        //5  10
    { 7,  8, NODE_NEXT},    //6  11

    { 9, 10, NODE_NEXT},    //7  110
    {11, 12, NODE_NEXT},    //8  111
    { 1,  2,    4 },        //9  1100
    { 1,  2,    5 },        //10 1101
    { 1,  2,    6 },        //11 1110
    {13, 14, NODE_NEXT},    //12 1111

    {15, 16, NODE_NEXT},    //13 11110
    {17, 18, NODE_NEXT},    //14 11111
    { 1,  2,    7 },        //15 111100
    { 1,  2,    9 },        //16 111101
    {19, 20, NODE_NEXT},    //17 111110
    {21, 22, NODE_NEXT},    //18 111111

    { 1,  2,    8 },        //19 1111100
    {23, 24, NODE_NEXT},    //20 1111101
    {25, 26, NODE_NEXT},    //21 1111110
    {27, 28, NODE_NEXT},    //22 1111111

    { 1,  2,   10 },        //23 11111010
    { 1,  2,   11 },        //24 11111011
    { 1,  2,   12 },        //25 11111100
    { 1,  2,   15 },        //26 11111101
    {29, 30, NODE_NEXT},    //27 11111110
    {31, 32, NODE_NEXT},    //28 11111111

    { 1,  2,   13 },        //29 111111100
    { 1,  2,   14 },        //30 111111101
    {33, 34, NODE_NEXT},    //31 111111110
    {35, 36, NODE_NEXT},    //32 111111111

    { 1,  2,   18 },        //33 1111111100
    {37, 38, NODE_NEXT},    //34 1111111101
    {39, 40, NODE_NEXT},    //35 1111111110
    {41, 42, NODE_NEXT},    //36 1111111111

    { 1,  2,   16 },        //37 11111111010
    { 1,  2,   17 },        //38 11111111011
    { 1,  2,   20 },        //39 11111111100
    {43, 44, NODE_NEXT},    //40 11111111101
    {45, 46, NODE_NEXT},    //41 11111111110
    {47, 48, NODE_NEXT},    //42 11111111111

    { 1,  2,   19 },        //43 111111111010
    { 1,  2,   21 },        //44 111111111011
    { 1,  2,   26 },        //45 111111111100
    {49, 50, NODE_NEXT},    //46 111111111101
    {51, 52, NODE_NEXT},    //47 111111111110
    {53, 54, NODE_NEXT},    //48 111111111111

    { 1,  2,   22 },        //49 1111111111010
    { 1,  2,   25 },        //50 1111111111011
    { 1,  2,   27 },        //51 1111111111100
    {55, 56, NODE_NEXT},    //52 1111111111101
    {57, 58, NODE_NEXT},    //53 1111111111110
    {59, 60, NODE_NEXT},    //54 1111111111111

    { 1,  2,   29 },        //55 11111111111010
    { 1,  2,   24 },        //56 11111111111011
    { 1,  2,   30 },        //57 11111111111100
    { 1,  2,   31 },        //58 11111111111101
    { 1,  2,   36 },        //59 11111111111110
    { 1, 60, NODE_END}      //60 11111111111111
};


//This array encodes internals of all number x from 8 to 15016, inclusive,
//that satisfies that (2*x+1) is co-prime to 2x3x5x7x11x13 = 30030
const uchar gSearch1[1739] =
{
    0x1F, 0x8C, 0xC4, 0x22, 0xC9, 0x46, 0xC4, 0xC7, 0x58, 0xCA, 0x62, 0x91, 0x3B, 0x31, 0xB6, 0x22,
    0xC9, 0x47, 0x6C, 0x5A, 0x8C, 0xCA, 0xC8, 0x59, 0x16, 0xB1, 0x11, 0x6F, 0x24, 0x3B, 0xE4, 0xB2,
    0xA2, 0xC5, 0x28, 0x59, 0x16, 0x8B, 0xB2, 0x49, 0xB2, 0x91, 0x9C, 0x1C, 0x9B, 0x65, 0x49, 0x64,
    0x59, 0xC4, 0x47, 0x2C, 0x72, 0x76, 0xC4, 0x26, 0x2B, 0x4A, 0x8C, 0x45, 0x96, 0x25, 0x27, 0xB1,
    0x46, 0xDA, 0x91, 0x9C, 0x0D, 0xA7, 0xC4, 0xC8, 0xD8, 0x43, 0x8C, 0xC4, 0xA3, 0xB6, 0x11, 0x71,
    0x3A, 0xE3, 0xC4, 0x46, 0xE4, 0x16, 0x31, 0x16, 0x9B, 0x24, 0x1B, 0xC3, 0xC9, 0x30, 0xCA, 0x9A,
    0x64, 0x59, 0x64, 0x49, 0x36, 0x92, 0x6C, 0x92, 0xDB, 0x30, 0x4E, 0x9C, 0x44, 0x96, 0x0D, 0x23,
    0xD9, 0xC8, 0x6B, 0x12, 0x27, 0xC3, 0xA6, 0x8C, 0x44, 0xF6, 0xF0, 0x48, 0x2C, 0x2E, 0x5F, 0xC4,
    0xC9, 0x70, 0x4A, 0x8C, 0xC4, 0xE3, 0x32, 0xB2, 0x22, 0xC9, 0x46, 0xC4, 0xC7, 0x58, 0x4A, 0x96,
    0xC5, 0x67, 0x11, 0xA3, 0x2D, 0x96, 0x6C, 0xC4, 0xA6, 0xC5, 0x28, 0x31, 0x92, 0x96, 0x0D, 0x1B,
    0xF1, 0x48, 0xB2, 0x43, 0x9C, 0x8C, 0xA5, 0x2D, 0x12, 0x59, 0xCE, 0xE2, 0x2C, 0x92, 0x7C, 0x24,
    0x27, 0xC3, 0xA6, 0x96, 0x8C, 0x65, 0x11, 0x27, 0xB1, 0xC6, 0xB1, 0x11, 0xB9, 0xAC, 0x28, 0x31,
    0x4A, 0x96, 0x25, 0x23, 0xB1, 0x47, 0xDA, 0x11, 0x71, 0x76, 0x9C, 0x16, 0x23, 0x63, 0x59, 0xC4,
    0x46, 0x2C, 0xAA, 0x1D, 0xB1, 0xC9, 0x31, 0x4A, 0xEC, 0x90, 0x65, 0x11, 0x67, 0xB1, 0x49, 0xB2,
    0x71, 0x9C, 0x0C, 0xA3, 0x2C, 0x4A, 0xF6, 0x10, 0x23, 0xF9, 0x90, 0x6C, 0x23, 0x72, 0x2D, 0xC6,
    0x89, 0x93, 0xC8, 0x6D, 0x18, 0x89, 0x45, 0xB2, 0xCD, 0xE2, 0x64, 0x18, 0x95, 0x8D, 0xC8, 0x1E,
    0xB2, 0x24, 0x16, 0x4B, 0x3E, 0x89, 0xB3, 0x61, 0x94, 0x38, 0x89, 0xC7, 0x89, 0x91, 0x6C, 0xE4,
    0xD8, 0x88, 0xF8, 0x18, 0x3B, 0x89, 0xB1, 0xC8, 0x2D, 0x16, 0x59, 0x51, 0xD9, 0x61, 0xD3, 0xE2,
    0x94, 0x18, 0x49, 0xCB, 0x92, 0x8D, 0x1D, 0x49, 0x76, 0x88, 0x8F, 0x61, 0xB4, 0x2C, 0x89, 0xC7,
    0x62, 0x51, 0x16, 0x4B, 0x36, 0x92, 0x93, 0x61, 0x93, 0x2C, 0x49, 0xCB, 0x86, 0x93, 0x58, 0xE4,
    0xD8, 0x88, 0x38, 0xD9, 0x51, 0x16, 0x89, 0x2C, 0x97, 0xB1, 0x58, 0x23, 0xBD, 0x22, 0xCE, 0x86,
    0x53, 0x19, 0x19, 0xCB, 0x22, 0x46, 0x62, 0x4D, 0xD9, 0x88, 0x5C, 0x5E, 0x94, 0xD8, 0x24, 0xCB,
    0x22, 0xC6, 0x62, 0x93, 0x64, 0x63, 0x38, 0x39, 0x46, 0x5B, 0x94, 0x2C, 0x8B, 0xD8, 0xC8, 0x46,
    0xD2, 0x8E, 0xF8, 0x64, 0x18, 0x27, 0xCE, 0x22, 0xCB, 0x86, 0x93, 0x58, 0x24, 0xDB, 0x94, 0x93,
    0x61, 0x54, 0x46, 0x22, 0x7B, 0xC8, 0x92, 0x78, 0x2C, 0xFB, 0x88, 0x38, 0x2D, 0xC6, 0x89, 0x91,
    0xF8, 0x9C, 0x18, 0x89, 0x45, 0x92, 0x8D, 0xE1, 0x63, 0x2C, 0x25, 0x76, 0xC8, 0x2D, 0xB2, 0x64,
    0x45, 0x92, 0x4D, 0x36, 0x1F, 0x8C, 0x12, 0x27, 0x69, 0x59, 0xC4, 0x46, 0x3E, 0xE4, 0xD8, 0x21,
    0x4E, 0x86, 0xCD, 0x62, 0x24, 0xB2, 0x2C, 0x16, 0x65, 0x51, 0xD9, 0x91, 0x93, 0xE1, 0x93, 0x2C,
    0x89, 0x2C, 0x4B, 0x4E, 0x56, 0xE4, 0xD8, 0x88, 0xF8, 0x58, 0x51, 0xB2, 0x24, 0x1E, 0x4B, 0x46,
    0x59, 0x47, 0x3B, 0x22, 0xCE, 0x86, 0x53, 0x62, 0xE4, 0x2C, 0x1B, 0x46, 0x62, 0x51, 0xD9, 0x88,
    0x38, 0x39, 0x4B, 0x59, 0x23, 0xB2, 0x9C, 0x18, 0x8B, 0x4D, 0x92, 0x8F, 0xE1, 0x64, 0x18, 0xB5,
    0xD1, 0xB2, 0x2C, 0x62, 0x24, 0xDB, 0x48, 0x36, 0x22, 0x97, 0x15, 0x27, 0x4E, 0xC9, 0xB2, 0x61,
    0x24, 0x36, 0xC9, 0x36, 0x89, 0x93, 0x63, 0x74, 0x46, 0x22, 0x7B, 0xC8, 0x8E, 0x58, 0x2C, 0xBD,
    0x62, 0x93, 0x61, 0x94, 0x18, 0x8B, 0xC7, 0x89, 0x93, 0x58, 0x24, 0xD9, 0x48, 0x3E, 0xC6, 0x52,
    0x62, 0x2C, 0xF2, 0x8D, 0x18, 0xD9, 0x91, 0x6C, 0x23, 0x36, 0x2D, 0xC6, 0x89, 0x91, 0x74, 0x8B,
    0xD8, 0x88, 0x47, 0x92, 0x5D, 0x38, 0x19, 0x46, 0x8B, 0x8D, 0xC8, 0xB2, 0x78, 0x94, 0x45, 0x92,
    0x4D, 0x39, 0x1B, 0x36, 0xC9, 0x25, 0xB2, 0x2C, 0xE2, 0x24, 0x1B, 0x39, 0x36, 0x22, 0x4E, 0x56,
    0x93, 0x18, 0x89, 0x2C, 0xCB, 0x46, 0x62, 0x4D, 0xED, 0x21, 0xCE, 0x86, 0x53, 0x62, 0x64, 0x2C,
    0x4B, 0x46, 0x56, 0x54, 0x36, 0x22, 0x3E, 0x8E, 0x51, 0xB2, 0x23, 0x1E, 0x8B, 0x18, 0x67, 0xB3,
    0x64, 0x63, 0x38, 0x19, 0x46, 0x59, 0x54, 0xCB, 0x86, 0x91, 0x6C, 0x24, 0xD9, 0x88, 0x5C, 0xC6,
    0x72, 0x36, 0x89, 0x2C, 0x1F, 0x8C, 0xC5, 0x22, 0xD9, 0x27, 0x71, 0x32, 0x8C, 0xCA, 0xC8, 0xD8,
    0x43, 0x96, 0xC4, 0x3A, 0xF2, 0x11, 0xB9, 0xAC, 0x28, 0x31, 0xCA, 0xE3, 0xC4, 0x48, 0x6C, 0x92,
    0x6C, 0x44, 0x7C, 0x9C, 0xA5, 0xC5, 0x58, 0xE4, 0x16, 0xB1, 0xB1, 0x22, 0x69, 0x47, 0x6C, 0x5A,
    0x8C, 0x12, 0x63, 0x69, 0x59, 0xC4, 0x47, 0x3C, 0x92, 0xEC, 0xC8, 0xC9, 0x30, 0x5A, 0x8C, 0x44,
    0xF6, 0xB0, 0x28, 0x8F, 0x64, 0x1B, 0xC9, 0x69, 0xB1, 0x47, 0x96, 0x44, 0x6E, 0x11, 0x27, 0xB1,
    0xC8, 0xB1, 0x31, 0x9C, 0xAC, 0x28, 0xB1, 0x11, 0x59, 0x96, 0x96, 0xC4, 0x1A, 0x69, 0x27, 0x71,
    0x36, 0x9C, 0x12, 0x27, 0x63, 0x59, 0xC4, 0x48, 0x36, 0x3A, 0x1B, 0x11, 0x27, 0xC7, 0x26, 0xB1,
    0x11, 0x59, 0x16, 0x8B, 0xC5, 0xA6, 0xB2, 0x0B, 0x27, 0xC3, 0x29, 0x8B, 0x92, 0x65, 0xC9, 0xC8,
    0x8B, 0x24, 0x1B, 0x91, 0xD7, 0x30, 0x4E, 0x2E, 0xF1, 0xD8, 0x30, 0xCA, 0x62, 0xD9, 0x26, 0x71,
    0x32, 0x8C, 0xCA, 0x48, 0xDA, 0x8B, 0x25, 0xB1, 0x58, 0xF2, 0x11, 0x71, 0x32, 0x96, 0xB2, 0x48,
    0x3C, 0x4E, 0x8C, 0xC5, 0x22, 0xC9, 0x47, 0xC4, 0xC7, 0x58, 0x2A, 0x63, 0xE3, 0x16, 0x31, 0xB2,
    0x1A, 0xC9, 0x46, 0x7C, 0xDA, 0xA2, 0xC4, 0xA8, 0x96, 0x45, 0x6C, 0xC4, 0x27, 0xC9, 0x0E, 0x71,
    0x72, 0x8C, 0x16, 0x23, 0x91, 0x65, 0xB1, 0x26, 0x8B, 0xA4, 0x1D, 0xD9, 0xC9, 0xB0, 0x49, 0x96,
    0x45, 0x96, 0x45, 0x9C, 0xC4, 0x22, 0xC7, 0x46, 0x72, 0xB2, 0xA2, 0xC4, 0x48, 0x64, 0x8F, 0x8C,
    0xC4, 0x1B, 0xF9, 0x8C, 0x88, 0xF3, 0xC1, 0x39, 0x31, 0x32, 0x6E, 0x11, 0x23, 0xB1, 0xA8, 0x6C,
    0x0C, 0x27, 0xC7, 0x28, 0xB1, 0x11, 0x59, 0x16, 0x59, 0x16, 0x9B, 0x24, 0x9B, 0xC5, 0xD9, 0x30,
    0xCA, 0xA6, 0x64, 0x59, 0xC4, 0x48, 0x36, 0x72, 0x6C, 0x44, 0x2E, 0xC3, 0x1E, 0x71, 0x12, 0x59,
    0xB6, 0x22, 0xB1, 0xA8, 0xED, 0x11, 0x27, 0xC3, 0xA9, 0x8C, 0x44, 0xF6, 0x68, 0xC9, 0x8A, 0x25,
    0x1F, 0x11, 0x1F, 0xC3, 0x28, 0x59, 0x12, 0x8F, 0x13, 0xA3, 0x2C, 0x96, 0x6C, 0x44, 0x7C, 0x8C,
    0xA5, 0xC4, 0x58, 0xBA, 0x0D, 0x23, 0x2B, 0x92, 0x6C, 0xC4, 0xA6, 0x65, 0x29, 0x8B, 0xA4, 0xE5,
    0xC4, 0x0E, 0x8F, 0x24, 0x5F, 0xC4, 0xC9, 0x30, 0x3A, 0x23, 0x63, 0x59, 0x2C, 0xCA, 0x1A, 0xC9,
    0x46, 0xBA, 0xAC, 0x26, 0x59, 0x4A, 0x96, 0x45, 0x9C, 0xC4, 0x26, 0xC7, 0x46, 0xC4, 0xC9, 0x8B,
    0x16, 0x23, 0x91, 0x65, 0xC9, 0x46, 0xAC, 0x91, 0x76, 0xC4, 0x66, 0xC3, 0x29, 0x31, 0x36, 0x96,
    0x45, 0x9C, 0xC4, 0xA2, 0xB2, 0x91, 0x9C, 0x1C, 0xA3, 0xC4, 0x46, 0x64, 0x0F, 0x31, 0x16, 0x9F,
    0x64, 0x1B, 0xC3, 0x69, 0x31, 0xCE, 0xA2, 0xE4, 0x16, 0x31, 0x92, 0x8D, 0x24, 0x1B, 0xE3, 0x32,
    0x8C, 0x13, 0x1F, 0x91, 0x65, 0x63, 0x49, 0x2C, 0x92, 0x6D, 0x12, 0x67, 0xC3, 0xA8, 0x9C, 0x44,
    0xF6, 0x90, 0x25, 0xD9, 0xD8, 0xF1, 0x11, 0x71, 0x32, 0x6C, 0x12, 0x23, 0xF1, 0x38, 0x8B, 0xC4,
    0xA2, 0xB2, 0x43, 0x7C, 0x8C, 0x2B, 0x31, 0x16, 0xB9, 0x25, 0x23, 0x2B, 0x92, 0x6C, 0xC4, 0x9E,
    0xC5, 0x28, 0x59, 0x92, 0x0F, 0x8B, 0xD8, 0xE4, 0xB1, 0x64, 0x87, 0x38, 0x19, 0x46, 0x8B, 0x91,
    0xB4, 0x6C, 0x45, 0x59, 0x24, 0xD9, 0x48, 0x4E, 0xC6, 0x4E, 0x1E, 0x89, 0x2C, 0x27, 0xCE, 0x62,
    0x91, 0xE3, 0x23, 0xE2, 0x64, 0x45, 0x65, 0x64, 0x2C, 0x4B, 0x46, 0x62, 0x8D, 0xB4, 0x23, 0x72,
    0x5B, 0x53, 0x62, 0xB4, 0x2C, 0x8B, 0x18, 0x89, 0x4D, 0x65, 0x23, 0xE2, 0xE4, 0x18, 0x2D, 0x36,
    0x22, 0xCB, 0x22, 0x76, 0xD8, 0x24, 0xED, 0x58, 0x93, 0x61, 0x94, 0xC5, 0xC9, 0xB2, 0x88, 0x93,
    0x6C, 0x24, 0xD9, 0x48, 0x97, 0x61, 0x9C, 0x38, 0x89, 0xEC, 0x85, 0x91, 0x78, 0x24, 0xDB, 0x24,
    0x4E, 0x8B, 0x71, 0x19, 0x89, 0x7C, 0x23, 0x4B, 0x62, 0xB1, 0xE4, 0x63, 0x38, 0x19, 0x46, 0x89,
    0x8D, 0x78, 0x9C, 0x2C, 0x89, 0x45, 0x92, 0x4D, 0xE2, 0x1B, 0x4B, 0x89, 0xB3, 0xC8, 0x2D, 0x62,
    0xE4, 0x45, 0x8E, 0x8D, 0xD8, 0xB4, 0xD8, 0x24, 0x46, 0xD2, 0xB2, 0x58, 0x23, 0x1E, 0x95, 0x1D,
    0xE2, 0x64, 0x38, 0x2D, 0x46, 0x22, 0xCB, 0xB2, 0xD1, 0x16, 0x49, 0x36, 0x92, 0x8F, 0x61, 0x93,
    0x2C, 0x89, 0xC7, 0x22, 0x4E, 0x59, 0xEC, 0xD8, 0x88, 0x38, 0x59, 0x51, 0x62, 0x24, 0x2D, 0x3B,
    0x46, 0x62, 0x8D, 0xB4, 0x23, 0xE2, 0x6C, 0x5C, 0x59, 0x64, 0x2C, 0x27, 0xC6, 0x62, 0x51, 0xF9,
    0x88, 0x38, 0x39, 0x46, 0x65, 0x63, 0x2C, 0x8B, 0x18, 0x8B, 0x3D, 0x92, 0x8D, 0x71, 0x59, 0x51,
    0x16, 0x25, 0xCB, 0x22, 0x46, 0xB2, 0x93, 0x64, 0x23, 0x72, 0x39, 0xC6, 0x07, 0x27, 0x91, 0x65,
    0xC3, 0x46, 0x2C, 0x92, 0xCF, 0x64, 0x93, 0x61, 0x54, 0xC6, 0x22, 0x7B, 0xC8, 0x25, 0x16, 0x4B,
    0x3E, 0x92, 0x93, 0x61, 0x94, 0x18, 0x89, 0xF7, 0x88, 0x91, 0x78, 0x24, 0xDB, 0x88, 0xF8, 0x2C,
    0xCB, 0x89, 0xB1, 0xC8, 0x2D, 0x62, 0x64, 0x45, 0x92, 0x8D, 0x35, 0x2D, 0x46, 0x89, 0x8D, 0xB4,
    0x2C, 0xB2, 0x23, 0x1E, 0x49, 0xF6, 0x88, 0xB3, 0x61, 0xB4, 0x38, 0x89, 0x2C, 0x8B, 0x45, 0x6D,
    0xE4, 0xD8, 0x48, 0x4E, 0x86, 0x4D, 0xB2, 0x24, 0xB2, 0x2C, 0x36, 0x89, 0x45, 0x67, 0x87, 0x38,
    0x59, 0x53, 0x62, 0x24, 0xB2, 0x2C, 0x19, 0x59, 0x8D, 0xB4, 0x23, 0xE2, 0x1B, 0x4E, 0xC9, 0x92,
    0x1D, 0x8B, 0x18, 0x65, 0x71, 0xD9, 0x88, 0x38, 0x39, 0x46, 0x89, 0x8D, 0xB4, 0x6C, 0x18, 0x8B,
    0x4D, 0x92, 0x8D, 0xE1, 0x64, 0x2C, 0x65, 0x51, 0xB2, 0x9C, 0x18, 0xCB, 0x46, 0x92, 0x8F, 0xC8,
    0x65, 0x18, 0x97, 0x93, 0xB1, 0x6C, 0x18, 0x89, 0x35, 0xB2, 0x4D, 0x72, 0x59, 0x51, 0x19, 0x25,
    0x7B, 0xC8, 0x92, 0xD8, 0x2C, 0xF9, 0x88, 0x38, 0x39, 0x46, 0x8B, 0x91, 0x78, 0x9C, 0xD8, 0x88,
    0x45, 0xD2, 0x8E, 0xD8, 0x63, 0x2C, 0x25, 0xC6, 0x22, 0xB7, 0x88, 0x93, 0x15, 0x49, 0x36, 0xB2,
    0xD3, 0x62, 0x94, 0x18, 0x49, 0x7B, 0x88, 0x8D, 0x78, 0x24, 0xDB, 0x21, 0x4E, 0x8B, 0xF1, 0xC1,
    0x48, 0xE4, 0x16, 0x8B, 0xB2, 0x48, 0xB2, 0x71, 0x9C, 0x0C, 0x9B, 0x64, 0x47, 0x64, 0x59, 0xE4,
    0x12, 0x8B, 0x1C, 0x9B, 0xC4, 0xD9, 0x8A, 0x12, 0x27, 0x91, 0x65, 0xC9, 0x48, 0xB6, 0x71, 0x76,
    0x44, 0x9C, 0x0D, 0x9F, 0xC4, 0xC8, 0x58, 0x16, 0x8B, 0xC4, 0xA2, 0xB2, 0x43, 0x9C, 0x1C, 0xA7,
    0xC4, 0x46, 0x64, 0x59, 0x32, 0xB6, 0x26, 0xC9, 0xC6, 0xF0, 0x31, 0x8C, 0xF2, 0x28, 0x8F, 0x45,
    0x8C, 0xDA, 0x58, 0xB2, 0x11, 0xB9, 0x0C, 0xE3, 0xC4, 0x49, 0x5A, 0x36, 0x8C, 0xC4, 0x22, 0xD9,
    0x26, 0x71, 0x32, 0x96, 0xDA, 0x48, 0x64, 0x1F, 0x59, 0x16, 0x8B, 0x25, 0x1F, 0x11, 0x27, 0xC3,
    0xA8, 0x8C, 0xEC, 0x38, 0x31, 0x12, 0x6B, 0x24, 0x1B, 0x91, 0xD7, 0x8E, 0x12, 0xE3, 0xE4, 0x16,
    0x31, 0xB2, 0x26, 0xC9, 0x46, 0x6C, 0x3A, 0xA3, 0xC5, 0x48, 0x5A, 0x16, 0xB1, 0x11, 0x8F, 0xA4,
    0x3D, 0x6C, 0x32, 0x8C, 0x16, 0x63, 0x91, 0x65, 0xB1, 0x29, 0x8B, 0x24, 0x1B, 0xC9, 0xC9, 0xB0,
    0x49, 0x96, 0x44, 0xF6, 0x10, 0x27, 0xF1, 0xC8, 0x6B, 0x44, 0x9C, 0xB6, 0x38, 0x31, 0x12, 0xB9,
    0x25, 0x23, 0xB1, 0x46, 0xDA, 0x31, 0x9C, 0x0D, 0xA7, 0xC4, 0xC6, 0x58, 0x16, 0x59, 0x12, 0x8B,
    0xCA, 0x26, 0x71, 0x76, 0x8C, 0x12, 0x1F, 0x91, 0x65, 0x11, 0x63, 0xD9, 0xC9, 0xB1, 0x31, 0x9C,
    0x0C, 0x9B, 0x2C, 0x4A, 0x96, 0xC5, 0x22, 0xD9, 0xA8, 0xEC, 0x90, 0xCB, 0x70, 0x4E, 0x9C, 0x44,
    0x96, 0x1D, 0x23, 0x2B, 0x92, 0x6D, 0x12, 0x1F, 0xC3, 0xA8, 0x96, 0xC4, 0x3B, 0x64, 0x29, 0x8B,
    0x25, 0x1F, 0x11, 0x27, 0xC3, 0x28, 0x31, 0x92, 0x0F, 0xFF, 0xFF    //Total 1739 bytes
};


//This array encodes intervals of all primes from 17 to 46337, inclusive.
const uchar gSearch2[2263] =
{
    0x1F, 0x8C, 0xC4, 0x22, 0xC9, 0x46, 0xC4, 0xC7, 0x58, 0xCA, 0x62, 0x91, 0x3B, 0x31, 0xB6, 0x22,
    0xD9, 0x47, 0x7C, 0x5A, 0x6C, 0xCA, 0xC6, 0x59, 0x96, 0x6C, 0xC4, 0x1B, 0xC7, 0x8E, 0xB7, 0x2D,
    0xDA, 0xA2, 0xE4, 0x16, 0x8B, 0xB3, 0xD9, 0xD9, 0x29, 0x27, 0xC7, 0x67, 0x8F, 0x45, 0xF6, 0x11,
    0x1F, 0xF1, 0xCB, 0xD9, 0xB1, 0x1E, 0x6B, 0x3A, 0x63, 0x69, 0x59, 0x7A, 0xC5, 0x9A, 0xFA, 0x66,
    0x67, 0x6B, 0xCE, 0xA2, 0xDB, 0x17, 0x23, 0xF1, 0xE8, 0xDF, 0x35, 0xEF, 0x3E, 0x62, 0x23, 0xDD,
    0x22, 0x76, 0x37, 0x97, 0x8D, 0xE3, 0x63, 0x18, 0xED, 0x57, 0xF2, 0x23, 0x7B, 0xEC, 0x54, 0x6F,
    0x72, 0x7B, 0xF3, 0x79, 0x12, 0xD9, 0xAB, 0x97, 0x0F, 0xDF, 0x4D, 0xE2, 0xB4, 0xEC, 0xB3, 0x1D,
    0xB2, 0xC7, 0x87, 0x64, 0xE7, 0xFD, 0xB1, 0xF9, 0xE0, 0x7C, 0x70, 0xCA, 0xE3, 0x3B, 0xB2, 0x27,
    0xC9, 0xAE, 0x1E, 0xBB, 0xC9, 0x3F, 0xEF, 0x8E, 0xD1, 0xF7, 0xF1, 0x19, 0xEF, 0x59, 0x9C, 0x12,
    0x1B, 0x69, 0xD9, 0xF1, 0xD9, 0x23, 0xF9, 0x3C, 0x36, 0xF9, 0xCE, 0xD6, 0xEC, 0x3D, 0x16, 0x7F,
    0xD9, 0xF1, 0x71, 0xAE, 0xB3, 0xAF, 0xE5, 0xF3, 0x47, 0x2E, 0xAF, 0x71, 0xBE, 0x91, 0xFB, 0x4B,
    0x65, 0x9C, 0xC7, 0xF2, 0xE1, 0xD3, 0xD7, 0x67, 0x44, 0xBE, 0xE7, 0x5A, 0x8C, 0x96, 0x5B, 0xF6,
    0xC9, 0xA6, 0x3E, 0x87, 0x4F, 0xCE, 0x4E, 0x7D, 0xC7, 0x3E, 0xF6, 0xB2, 0x8F, 0xEC, 0xE3, 0xBC,
    0x86, 0x71, 0x7E, 0x7D, 0x1F, 0x16, 0x7D, 0xD3, 0xA7, 0xA3, 0xFB, 0x60, 0x8F, 0xBC, 0x3F, 0x1B,
    0xCB, 0xB2, 0xB1, 0x6C, 0xF3, 0xBB, 0xEC, 0xB4, 0x6F, 0x77, 0xBC, 0x59, 0x2F, 0xFB, 0x24, 0xFE,
    0x70, 0x7D, 0xA6, 0xDE, 0x0F, 0x46, 0x6D, 0x77, 0x2F, 0xF9, 0xCE, 0x8F, 0x18, 0xE7, 0xF3, 0xBB,
    0xDD, 0xD3, 0x1E, 0x36, 0x2D, 0x3E, 0x65, 0x2C, 0x9F, 0x9B, 0xD7, 0x8E, 0xEA, 0x6F, 0x8F, 0xB3,
    0x73, 0xAF, 0xF8, 0x73, 0xF1, 0xA9, 0x67, 0x1F, 0x7F, 0xAB, 0x49, 0x2E, 0xE9, 0x3B, 0x7C, 0xF1,
    0xC8, 0x3F, 0xE5, 0xEC, 0xBF, 0x3E, 0x24, 0xB2, 0x4F, 0xCE, 0xF6, 0x25, 0xFD, 0x3A, 0x5B, 0xD3,
    0x19, 0x19, 0xCB, 0xA7, 0x2F, 0xEF, 0xF9, 0xDB, 0x97, 0xEF, 0x64, 0x4F, 0x2D, 0x7B, 0xB3, 0xEC,
    0xDC, 0xFE, 0xE0, 0xE4, 0xBC, 0x5B, 0xB4, 0xC7, 0x56, 0xD3, 0x46, 0xB5, 0xF3, 0xD3, 0x37, 0xAF,
    0xB3, 0xBF, 0xF3, 0xCA, 0x46, 0xBE, 0x73, 0xEF, 0x27, 0xAE, 0x65, 0x69, 0x1F, 0x7F, 0xF8, 0xB0,
    0xEC, 0x97, 0x38, 0x9F, 0xE2, 0x3E, 0x63, 0xBF, 0x2C, 0x59, 0x93, 0xD7, 0x9C, 0xCF, 0xED, 0x4F,
    0x17, 0xDF, 0xF3, 0x6E, 0x8F, 0xB4, 0x93, 0xFD, 0x3E, 0xCB, 0x2D, 0x1F, 0xDE, 0x9F, 0xB7, 0xCF,
    0x1B, 0xAF, 0xB1, 0xB3, 0x35, 0xC6, 0x72, 0x16, 0xE7, 0xF3, 0xDA, 0x97, 0x93, 0xE3, 0x93, 0xCF,
    0xC9, 0xAF, 0x3F, 0x75, 0xF7, 0x24, 0xBE, 0xDD, 0xE4, 0x71, 0xBF, 0x1F, 0xFA, 0x7E, 0xDA, 0x0B,
    0x67, 0xEB, 0xE7, 0xC9, 0xB9, 0x77, 0x59, 0xEC, 0x2B, 0x1F, 0xF1, 0xE9, 0x7E, 0xB6, 0x59, 0x7E,
    0x8D, 0xF3, 0xE9, 0xDF, 0x37, 0x2D, 0x7E, 0xED, 0x7C, 0xD8, 0x47, 0xAE, 0x4F, 0xE3, 0xD8, 0xD4,
    0x65, 0xCD, 0xEB, 0x97, 0xC7, 0xC6, 0x1E, 0x7E, 0xF5, 0x9B, 0xB3, 0x17, 0x7F, 0x49, 0x3E, 0x47,
    0x3B, 0x3F, 0xD7, 0x9B, 0x4F, 0xDE, 0x74, 0x76, 0x1D, 0x9F, 0x2F, 0xD9, 0x77, 0x7C, 0xA4, 0xEF,
    0x9E, 0xDA, 0x58, 0xE4, 0x1B, 0xEB, 0x7A, 0xF6, 0x1A, 0xFF, 0x79, 0x2E, 0xE3, 0xBA, 0x0F, 0x3B,
    0xDF, 0x5C, 0xF6, 0x72, 0x79, 0xD3, 0xD9, 0xC5, 0x9D, 0x4F, 0x9F, 0xD8, 0x79, 0xFB, 0x37, 0x7F,
    0xF9, 0x8E, 0x3D, 0x72, 0xBE, 0x63, 0xC7, 0xC6, 0x7B, 0xEF, 0xCB, 0x1A, 0xF9, 0x1C, 0x3B, 0x8B,
    0x3D, 0xF7, 0x3D, 0x7F, 0xF1, 0x4B, 0x7C, 0xF6, 0xB8, 0x0F, 0x7F, 0xE7, 0x7B, 0xAC, 0xC7, 0xB9,
    0xF2, 0xCB, 0x97, 0xCB, 0x9E, 0x77, 0x67, 0xFF, 0xD5, 0x16, 0x7D, 0xE2, 0xFA, 0xCB, 0xCE, 0xA7,
    0x69, 0x7F, 0xBE, 0x96, 0xE5, 0xEC, 0x4B, 0xEE, 0x5D, 0x16, 0xBF, 0x3E, 0x7F, 0x9C, 0xBC, 0xE6,
    0x2E, 0xE7, 0x9B, 0xCF, 0xB3, 0xDD, 0x3D, 0xF9, 0xE5, 0x45, 0x7D, 0xE6, 0x9B, 0xBF, 0x93, 0x5F,
    0xDE, 0xCF, 0x97, 0xB3, 0x7C, 0xB8, 0xFB, 0x37, 0x76, 0x35, 0x49, 0x3F, 0x7E, 0x6D, 0x3D, 0x16,
    0xD7, 0xB2, 0x7D, 0xF9, 0x47, 0xFA, 0xE6, 0xC7, 0xB0, 0x9F, 0x46, 0xFE, 0xDD, 0x7C, 0x8E, 0x65,
    0x1B, 0xE7, 0xBE, 0x7B, 0xFC, 0x23, 0xB7, 0xE3, 0x9C, 0x4F, 0x9F, 0xC6, 0x9A, 0xF6, 0xA8, 0xCF,
    0xD4, 0x2D, 0xBD, 0x56, 0xF7, 0x4E, 0x3B, 0xAF, 0x4F, 0xEF, 0xCE, 0x1E, 0xDD, 0xFD, 0x63, 0x63,
    0xF8, 0x5E, 0x53, 0xBE, 0xC8, 0x8F, 0xF5, 0xFC, 0x66, 0xD7, 0x97, 0xE3, 0x94, 0xBF, 0xEC, 0xCD,
    0xCE, 0x4F, 0xE7, 0x63, 0xFC, 0x7D, 0x3E, 0x5C, 0x7E, 0x6D, 0x35, 0x7B, 0xCF, 0x3E, 0x9F, 0x67,
    0x9F, 0x3E, 0x4D, 0x9F, 0xAF, 0x25, 0xF1, 0x58, 0xFA, 0x0E, 0xDF, 0xD9, 0xF9, 0x66, 0xDF, 0x47,
    0x7C, 0xB1, 0x59, 0x7E, 0xFD, 0x65, 0x79, 0x7D, 0x7B, 0x16, 0xBF, 0xFE, 0xC9, 0x1E, 0xBF, 0xF6,
    0xF9, 0x8E, 0xDF, 0xDB, 0x17, 0x9F, 0xBE, 0x5F, 0x2E, 0xC7, 0x69, 0xB9, 0x77, 0x9F, 0xCF, 0x63,
    0x91, 0xFC, 0xE5, 0x6F, 0xD8, 0xE3, 0x3D, 0x9F, 0xC7, 0x26, 0xAB, 0x71, 0x7C, 0x3E, 0x93, 0x37,
    0x1F, 0x76, 0xEC, 0x4F, 0x3B, 0x76, 0xCF, 0xAF, 0xCF, 0xF7, 0x9C, 0xCD, 0xF6, 0x6C, 0xEC, 0xDD,
    0x53, 0xEF, 0x36, 0xAF, 0xD1, 0xB2, 0x53, 0xCB, 0xBB, 0x9C, 0xCD, 0xDE, 0x73, 0xCE, 0xD6, 0x97,
    0xCF, 0xE7, 0xD9, 0xD9, 0xE3, 0xED, 0xF6, 0x90, 0xCB, 0xF1, 0x7F, 0x89, 0xEC, 0xD5, 0x63, 0x35,
    0xFD, 0xF3, 0x1A, 0x57, 0xF9, 0x7C, 0x1F, 0xEF, 0xF6, 0xE7, 0x47, 0xC4, 0xC7, 0x9A, 0xCF, 0xF1,
    0xDF, 0xE2, 0x4F, 0xF1, 0xFA, 0xF4, 0xF7, 0x7D, 0xDA, 0xA3, 0xFB, 0xCD, 0x7A, 0xE4, 0xC7, 0xFA,
    0xB3, 0x6F, 0x53, 0xBF, 0xDE, 0xF1, 0x21, 0xEF, 0x25, 0xFF, 0x5C, 0xE7, 0xCF, 0xCF, 0xC5, 0xFD,
    0x1D, 0x3B, 0xDE, 0xAC, 0xAF, 0x0F, 0xF5, 0x6E, 0x38, 0xF5, 0xF3, 0x69, 0xB6, 0xE7, 0x7B, 0x3E,
    0x71, 0xF2, 0x3D, 0xEF, 0xBF, 0xE9, 0xB5, 0x66, 0xE7, 0x4D, 0x9C, 0x0F, 0x77, 0xBD, 0x56, 0x74,
    0xFB, 0x75, 0xAF, 0xF1, 0x61, 0x1F, 0x7F, 0xD9, 0xE3, 0xA7, 0xCF, 0x2C, 0xF7, 0x1D, 0x9F, 0xAF,
    0xE5, 0xEE, 0xDD, 0x8B, 0xA5, 0x7D, 0xB9, 0x8C, 0x9F, 0xBF, 0xC8, 0xF2, 0xB9, 0xF9, 0x26, 0xD9,
    0xBE, 0x6E, 0xE7, 0x2A, 0x5F, 0xBC, 0x97, 0x4B, 0x3E, 0x77, 0x8F, 0xF3, 0x7A, 0x4F, 0x39, 0xF9,
    0x75, 0xFB, 0xC8, 0x87, 0xFB, 0xB5, 0x9F, 0xAF, 0x9F, 0x9D, 0xDB, 0xEB, 0xAE, 0xF9, 0x3C, 0xD9,
    0x3F, 0x5F, 0xFB, 0x7B, 0xC8, 0xDF, 0x7B, 0xFA, 0x1E, 0xDF, 0x9E, 0xD7, 0xE8, 0xDF, 0x2F, 0x9F,
    0x5E, 0x7E, 0xA4, 0xEB, 0x76, 0xFA, 0xDC, 0xEC, 0xF3, 0x9F, 0xC8, 0x7B, 0x44, 0x9C, 0xB6, 0xA8,
    0xAE, 0x9F, 0x65, 0xBB, 0x7A, 0xEA, 0x7F, 0xBE, 0x5A, 0x76, 0xF6, 0x8E, 0x7C, 0x3E, 0x73, 0x7D,
    0xB3, 0xD3, 0x37, 0xDF, 0xCD, 0xDE, 0xB1, 0x1D, 0x3E, 0x4B, 0xAF, 0x37, 0xEF, 0x95, 0xF5, 0xC8,
    0x9D, 0xBD, 0xEF, 0xF1, 0xB9, 0x79, 0xF7, 0x8F, 0x4D, 0xC9, 0x7E, 0xD9, 0xF8, 0xB5, 0xFC, 0x1B,
    0x7F, 0xB8, 0xDB, 0xB8, 0xDF, 0xEE, 0x73, 0x7C, 0xBF, 0xF7, 0x2C, 0x77, 0x62, 0xC7, 0xE7, 0xE5,
    0x3F, 0xF3, 0x69, 0x16, 0xDF, 0xD9, 0x39, 0x5F, 0xDE, 0x45, 0x9C, 0xBF, 0xF4, 0x7D, 0x3D, 0xAF,
    0x4D, 0xED, 0xC8, 0xBB, 0x7D, 0x7D, 0x4F, 0xBF, 0xE2, 0xDB, 0x2F, 0x4E, 0x76, 0xCF, 0xBF, 0x9F,
    0x24, 0x1F, 0xE9, 0x2F, 0x36, 0xCB, 0xB2, 0xF8, 0xCB, 0xDD, 0xBE, 0xF7, 0x2C, 0xD7, 0xF6, 0x9C,
    0x8F, 0x2F, 0x3B, 0xCE, 0xDE, 0xFB, 0x4E, 0xEF, 0xE7, 0xA9, 0x7D, 0x8C, 0x3B, 0xEB, 0xF8, 0x70,
    0xF9, 0x24, 0xF7, 0xFA, 0xCF, 0x7B, 0x87, 0x38, 0xE7, 0x3F, 0xBD, 0xDC, 0x76, 0x3F, 0x53, 0x9F,
    0xE3, 0xDD, 0xAF, 0xA5, 0x57, 0xFE, 0x13, 0x1F, 0x9C, 0x77, 0x2F, 0x76, 0xEC, 0xD8, 0x77, 0xF2,
    0xCB, 0xFE, 0x89, 0xED, 0xA7, 0xE7, 0xD3, 0xCB, 0x7E, 0xED, 0x64, 0x2C, 0x27, 0xCE, 0x76, 0xEF,
    0x73, 0x9F, 0xE9, 0x33, 0xD2, 0xFB, 0xF3, 0xEE, 0xE1, 0xB3, 0xD5, 0x7B, 0xFC, 0x7D, 0x9F, 0xCF,
    0x3D, 0x3F, 0xF7, 0x1D, 0x3B, 0xE2, 0x73, 0xD9, 0x23, 0xFE, 0x46, 0xCB, 0xEF, 0x37, 0x36, 0xF5,
    0xB9, 0x6B, 0xE4, 0xE7, 0x6C, 0x6A, 0xE9, 0xFE, 0x3E, 0x79, 0xD3, 0xD9, 0xD3, 0x6D, 0x4D, 0x89,
    0x73, 0x3E, 0xEF, 0xF2, 0xE9, 0xAB, 0x1D, 0x7F, 0xFF, 0xB9, 0xF9, 0x3E, 0xBA, 0x4F, 0xF1, 0xFA,
    0xC7, 0x79, 0x77, 0xB6, 0xC7, 0xAF, 0xEF, 0xF7, 0xE6, 0xEF, 0xD5, 0x74, 0x3F, 0x9F, 0xC7, 0xE7,
    0xDA, 0xFB, 0xCA, 0x79, 0xEF, 0x5D, 0xFC, 0xDA, 0xC7, 0xD8, 0x9F, 0x17, 0xBF, 0x3E, 0xCF, 0x3E,
    0xD9, 0x57, 0x1B, 0xD7, 0xEF, 0x4E, 0x36, 0xFF, 0x41, 0xEE, 0xB5, 0xD9, 0xDE, 0x97, 0xFB, 0x4C,
    0x16, 0xFF, 0xF3, 0xF8, 0xF5, 0xC1, 0x8E, 0xEE, 0xF2, 0xD9, 0x7A, 0xF6, 0xF9, 0x4C, 0xE7, 0x7C,
    0xC7, 0xFB, 0x1D, 0x6F, 0x9F, 0x67, 0x3B, 0x72, 0xDE, 0xFB, 0xE0, 0xE3, 0xDC, 0xFD, 0x7E, 0x46,
    0xFA, 0xBE, 0xD9, 0xEA, 0xE9, 0xDD, 0x63, 0xF1, 0x8F, 0x37, 0xBE, 0xB3, 0xCF, 0xA7, 0x66, 0x9B,
    0x6E, 0xBF, 0x76, 0xBC, 0x3F, 0xAF, 0xF7, 0xF6, 0xDB, 0xF4, 0x7D, 0x58, 0x2C, 0x16, 0x7D, 0xBF,
    0xBD, 0x37, 0xD7, 0x1E, 0x1F, 0x96, 0x7D, 0xFB, 0x92, 0xBE, 0xEB, 0xED, 0xB9, 0x0F, 0xE5, 0x73,
    0xF2, 0x7E, 0xFE, 0xB9, 0x9E, 0xBF, 0x5C, 0x97, 0x7C, 0x7E, 0xE7, 0xA7, 0xDF, 0xE5, 0xB5, 0x9B,
    0x6F, 0xFA, 0x7E, 0x59, 0xF6, 0x97, 0xBF, 0x3D, 0x9F, 0xBE, 0x3E, 0xE4, 0xBF, 0xC4, 0x38, 0xEB,
    0xC8, 0x26, 0xBF, 0xFC, 0xD7, 0xCE, 0x87, 0x6F, 0x6C, 0xFA, 0x3C, 0xBE, 0xE3, 0x57, 0x77, 0x2D,
    0xCB, 0xFD, 0xBD, 0x97, 0x77, 0x67, 0xFF, 0x6F, 0x6C, 0x96, 0xFD, 0xE5, 0x9F, 0x36, 0x5E, 0x9B,
    0xCF, 0xF3, 0xE9, 0xF1, 0xCB, 0xD8, 0xA3, 0x2B, 0x8F, 0xBC, 0x46, 0x7A, 0xB7, 0xB9, 0xBE, 0xE9,
    0x5E, 0x9F, 0xFC, 0xEA, 0x33, 0xCE, 0xF7, 0x5C, 0x7D, 0xEE, 0xFD, 0x1D, 0xB1, 0x3F, 0x3E, 0x3F,
    0xDF, 0xD1, 0xF6, 0xD4, 0x6D, 0xDC, 0xDE, 0xBC, 0xEF, 0x36, 0x9F, 0x9A, 0xCF, 0x97, 0x2C, 0x7B,
    0x4D, 0xFB, 0xB5, 0xEF, 0x1F, 0xFB, 0xC5, 0xE9, 0xEE, 0x75, 0xBE, 0xE3, 0xFE, 0xDD, 0x7B, 0xF1,
    0xF7, 0xF9, 0x3C, 0x3E, 0x67, 0xF1, 0x8F, 0x7D, 0xDD, 0x4F, 0xDF, 0x7C, 0xDE, 0xBB, 0x97, 0xCA,
    0x1E, 0xF9, 0x9E, 0x6B, 0x9B, 0x7B, 0xAF, 0xE5, 0xFB, 0x29, 0xDF, 0xBE, 0xBE, 0xB9, 0x1F, 0xDF,
    0x97, 0x6F, 0xBC, 0xB9, 0x7D, 0xE4, 0xFD, 0xFC, 0x57, 0x75, 0xDB, 0x4D, 0xF6, 0xFC, 0xB6, 0xF3,
    0xDD, 0xDC, 0xB2, 0xB4, 0xEC, 0xBD, 0x5F, 0x39, 0xDF, 0xF5, 0xDB, 0xD3, 0x5D, 0xCB, 0xFE, 0xF2,
    0x19, 0xE9, 0x95, 0xFC, 0xE3, 0xB4, 0xD8, 0xD8, 0xEF, 0x51, 0x7E, 0x7D, 0x8F, 0xF8, 0xFF, 0x8D,
    0xF3, 0x8D, 0xCF, 0xE2, 0x57, 0xFB, 0xF6, 0xF5, 0x69, 0xF2, 0xEB, 0xBE, 0x91, 0xDB, 0x97, 0xEF,
    0xDE, 0x5F, 0xF6, 0xD9, 0xF9, 0xFC, 0xEF, 0x76, 0xF6, 0x7A, 0xF9, 0x0E, 0x9B, 0xDA, 0x97, 0x6F,
    0x3E, 0xCF, 0xC6, 0xED, 0x97, 0x4F, 0xFE, 0x83, 0x1D, 0x3E, 0x97, 0x91, 0x5F, 0xCB, 0x76, 0xFC,
    0xDC, 0x95, 0x3F, 0xF8, 0x43, 0x36, 0x9F, 0xD8, 0x7B, 0xFA, 0x77, 0x4F, 0xF2, 0xFB, 0x3D, 0x36,
    0xF2, 0x97, 0xFC, 0xF3, 0x7E, 0xD3, 0x27, 0x3E, 0xC7, 0x59, 0xCF, 0x36, 0xE7, 0xCB, 0xCE, 0xA7,
    0x7E, 0xD9, 0x97, 0x1D, 0xE7, 0x7E, 0xFE, 0xC3, 0x6D, 0xC7, 0x89, 0xBD, 0xCF, 0xE5, 0xF3, 0xEB,
    0xEC, 0xB4, 0xEF, 0xF8, 0x7C, 0x1A, 0x63, 0x39, 0xB1, 0xB1, 0x7F, 0xFD, 0xEC, 0xBC, 0x4B, 0x8B,
    0x6F, 0xC7, 0x87, 0xEF, 0x9A, 0xD7, 0xF7, 0x26, 0xBF, 0xFA, 0xFD, 0x3E, 0x7A, 0xFD, 0x7F, 0xE5,
    0x5A, 0xEE, 0xFE, 0xE2, 0xF3, 0x1D, 0xB5, 0x8F, 0x6C, 0xB3, 0xCF, 0xC6, 0x7D, 0xBF, 0xB3, 0xEF,
    0x71, 0x1E, 0x4B, 0x6F, 0xFD, 0x3B, 0xCE, 0xDE, 0x97, 0x4F, 0x4D, 0xFB, 0xCE, 0xCE, 0xE2, 0xFB,
    0xE7, 0xBE, 0x91, 0xEF, 0x7A, 0x3E, 0x7D, 0xED, 0xF1, 0xFE, 0xB7, 0x3F, 0xB4, 0x47, 0x3B, 0x76,
    0x37, 0x76, 0xBF, 0x5F, 0xFD, 0xB4, 0xC7, 0x7E, 0x95, 0xF7, 0xEC, 0x7B, 0xD3, 0xF9, 0x2C, 0xF7,
    0xFB, 0xE1, 0x12, 0xFB, 0xE3, 0x8B, 0x3D, 0xFF, 0xA7, 0xFF, 0xE1, 0x53, 0xF7, 0x47, 0xFA, 0x8E,
    0xBB, 0xF6, 0xE5, 0x6E, 0xDF, 0x6B, 0xDA, 0x46, 0xFC, 0xFA, 0xA9, 0x7D, 0x96, 0xEF, 0x9E, 0xFD,
    0xE3, 0x3B, 0x77, 0x7B, 0xCD, 0xA7, 0xA9, 0x6F, 0xF6, 0x6B, 0xFB, 0x5F, 0x6F, 0x8B, 0x3D, 0xFE,
    0x91, 0xDB, 0x71, 0xCE, 0x9B, 0xEF, 0x69, 0xDF, 0x9A, 0xCE, 0x79, 0xF7, 0x3A, 0x92, 0xCF, 0xDD,
    0xB3, 0x4F, 0x7B, 0x5C, 0xC6, 0xF9, 0xA7, 0xB7, 0x8D, 0x77, 0xC7, 0x3F, 0xFB, 0xD5, 0xE7, 0xEB,
    0x76, 0x96, 0x4F, 0x5F, 0xFB, 0xE5, 0x2F, 0xCE, 0x87, 0x57, 0xDA, 0xF7, 0x9E, 0xB7, 0xCF, 0x57,
    0x4E, 0x76, 0xB3, 0x5C, 0xD2, 0xF2, 0xB9, 0x67, 0x9B, 0xFE, 0xD2, 0xFB, 0xFB, 0x6F, 0x3E, 0xC7,
    0xFB, 0x69, 0x76, 0x76, 0xF6, 0x7F, 0x95, 0x5F, 0xE2, 0xF3, 0x77, 0xFA, 0x3C, 0xBF, 0xFD, 0xFA,
    0x6C, 0x8D, 0xEF, 0xC5, 0xF7, 0x4D, 0xE7, 0x63, 0xF8, 0x7E, 0xF5, 0xF9, 0xAF, 0x0F, 0xC6, 0x7F,
    0xFE, 0xFB, 0x31, 0x7E, 0x36, 0xDE, 0x3D, 0x3E, 0xF4, 0x69, 0x64, 0x9B, 0xE5, 0xFD, 0xCC, 0xBD,
    0xD7, 0x6D, 0xBD, 0xF7, 0xC8, 0x7E, 0x75, 0x7D, 0xFE, 0xF8, 0xE2, 0xBF, 0x76, 0xB2, 0x9E, 0x5E,
    0x79, 0x77, 0x76, 0x16, 0x63, 0xFF, 0x7B, 0xCE, 0x5E, 0x3E, 0x23, 0xFB, 0xDC, 0x7E, 0x39, 0xFB,
    0x5F, 0xC6, 0x7E, 0xED, 0x75, 0x7F, 0xCE, 0xF9, 0x3B, 0xCE, 0x4F, 0x3B, 0x7D, 0x6E, 0xF6, 0xE6,
    0x3B, 0x96, 0xB6, 0x26, 0x9F, 0xBF, 0xF3, 0x79, 0xC7, 0xBE, 0x7C, 0xE3, 0xE7, 0xA7, 0xEE, 0xE4,
    0x9B, 0x6D, 0xCE, 0xAF, 0x37, 0xEF, 0xA7, 0xFE, 0xCF, 0xE4, 0x9F, 0x7F, 0xC4, 0x3F, 0x77, 0xD6,
    0xDC, 0x72, 0x9F, 0xB7, 0xE9, 0xDE, 0xE5, 0xFF, 0xC8, 0xFE, 0xDE, 0x38, 0x9F, 0xE7, 0xB2, 0x0B,
    0x9F, 0xF3, 0xE9, 0xA7, 0xF6, 0xEE, 0xEB, 0xAD, 0xCF, 0xD8, 0x97, 0xFF, 0xF2, 0x59, 0xBA, 0x0F,
    0x76, 0xEC, 0x24, 0xFB, 0xD4, 0xBD, 0xFF, 0x9E, 0xED, 0x27, 0xF6, 0xF8, 0xDD, 0xE7, 0xEE, 0x53,
    0xBC, 0xF6, 0xFB, 0x58, 0x64, 0x4F, 0xCE, 0x5E, 0xFF, 0xDA, 0xF9, 0x66, 0xFB, 0x19, 0x7F, 0xE3,
    0x3E, 0x93, 0xCD, 0xE7, 0x29, 0xD9, 0xE3, 0xF3, 0x88, 0x5F, 0xEF, 0xB2, 0xDD, 0xEF, 0xBC, 0xB7,
    0x94, 0x77, 0x78, 0xEF, 0x0F, 0xDB, 0x7C, 0xA6, 0xDB, 0xA7, 0x2B, 0xF9, 0xB1, 0x49, 0xEC, 0x71,
    0xF6, 0xE7, 0xE7, 0xE8, 0xBE, 0x7F, 0xE9, 0xDD, 0x1A, 0x69, 0x67, 0x9B, 0x4F, 0x4F, 0xFE, 0xCC,
    0x72, 0xF9, 0x0F, 0xDF, 0x4D, 0x3B, 0xDD, 0x3E, 0xDB, 0x7B, 0x9C, 0x7F, 0xF6, 0xF9, 0xBC, 0xF3,
    0xDE, 0xF5, 0x79, 0x7E, 0xF6, 0xE6, 0x3B, 0xF6, 0xFF, 0x09, 0xE7, 0xF3, 0x6C, 0x3F, 0xDD, 0xFB,
    0xC3, 0xAF, 0x5C, 0x8B, 0x4F, 0x1F, 0x76, 0xBE, 0xBF, 0xF2, 0x5F, 0xBD, 0x22, 0xCE, 0xFF, 0x3C,
    0xDF, 0x7C, 0x7F, 0xED, 0x2C, 0xF9, 0xD8, 0x97, 0x71, 0xD7, 0x7D, 0xB8, 0x1D, 0xE3, 0xEF, 0xCD,
    0x1E, 0x3E, 0x7F, 0x27, 0x31, 0xEE, 0xFF, 0xEA, 0x59, 0xFA, 0xFB, 0x2F, 0x7F, 0x27, 0xBB, 0xC3,
    0x7A, 0x3E, 0xF3, 0x2B, 0x3B, 0xD9, 0x1F, 0x8F, 0x7D, 0xEF, 0x5E, 0xBC, 0xB9, 0xFD, 0x72, 0x3E,
    0x37, 0x7D, 0x66, 0xEF, 0xC9, 0x39, 0xBF, 0xFA, 0xCF, 0x7C, 0xFA, 0x87, 0x8C, 0xEF, 0x97, 0xED,
    0x9F, 0xE7, 0x7C, 0xC7, 0x67, 0xD9, 0x91, 0xF7, 0x73, 0xCF, 0x3E, 0xF5, 0xDF, 0x5B, 0x5F, 0x3B,
    0xE7, 0xBD, 0xEC, 0xF3, 0xEE, 0x3B, 0xF9, 0xB4, 0xBF, 0x4F, 0x79, 0xFF, 0x25, 0x36, 0xB7, 0xBD,
    0xFD, 0xEF, 0xEC, 0x66, 0xFF, 0xD5, 0x37, 0x7B, 0x2F, 0xF9, 0x3B, 0xF5, 0x2E, 0xDE, 0xD7, 0xCE,
    0xCF, 0xD2, 0x77, 0xBC, 0xFB, 0xFF, 0xFF
};


static void BN_Text2Key(const uchar* p, BN* pKey, uint nKeyBytes);
static void BN_Key2Text(const BN* pKey, uchar* p, uint nKeyBytes);


typedef union U8
{
    uint64_t    u8;
    struct {
#ifdef BIG_ENDIAN
        uint    high;
        uint    low;
#else //BIG_ENDIAN
        uint    low;
        uint    high;
#endif //BIG_ENDIAN
    }           u4;
} U8;


/******************************************************************************
* Function:     GetN0
*
* Description:  Calculate n0 in Montgomery Multiplication. n0 = -M^-1 mod W.
*
* Returns:      The n0 calculated.
******************************************************************************/
uint GetN0(uint M)
{
    uint    n0 = M;

    // First figure out n0, n0 = -M^-1 mod W, M*M^-1 mod W == 1, W = 2^32;
    // fast inversion mod 2^32, based on the fact that
    //
    // X*M = 1 (mod 2^n)    =>  (X(2-X*M)) M = 1 (mod 2^2n)
    //                      =>  2*X*M - X*X*M*M = 1
    //                      =>  2*(1) - (1)     = 1

    //First calculate M^-1, which gives M*M^-1 mod W == 1, W = 2^32.
    n0  = M;
    n0 += (((n0 + 2) & 4) << 1);    // n0 * M ==1 mod 2^4
    n0 *= 2 - M * n0;     // here n0*M==1 mod 2^8
    n0 *= 2 - M * n0;		// here n0*M==1 mod 2^16; each step doubles the bits
    n0 *= 2 - M * n0;		// here n0*M==1 mod 2^32

    //Now n0 = -M^-1 mod W
    return (n0 = 0 - n0);
}


/******************************************************************************
* Function:     GetWBits
*
* Description:  Get number of bits in 32 bits integer W. When W=0, return 1 bit.
*
* Returns:      Number of effective bits in W.
******************************************************************************/
uint GetWBits(uint W)
{
    uint    n = 32;

    W |= 1;
    while (W < 0x01000000) {W <<= 8; n-=8;}
    while ((int)W > 0) {W <<= 1; n--;}

    return n;
}


void BN_set(BN* pX, uint M)
{
    uint    i;

    pX->data[0] = M;
    for (i = 1; i<sizeof(BN)/sizeof(pX->data[0]); i++) {
        pX->data[i] = 0;
    }
}


uint BN_modw(const BN* pX, uint M)
{
    uint    i, v= pX->data[BN_SIZE-1]%M, R = (0xFFFFFFFFU%M)+1;
    R -= (-(R >= M))&M;
    for (i = BN_SIZE-1; i-- > 0; ) {
        v = (v*R) + pX->data[i];
        v += ((-(v < pX->data[i]))&R);
        v %= M;
    }
    return v;
}


/******************************************************************************
* Function:     BN_getBits
*
* Description:  Return number of bits contained in BN. Special case When BN=0
*               will cause ambiguity as it will return 0. It should never happen.
*
* Returns:      Number of bits in BN
******************************************************************************/
uint BN_getBits(const BN* pX)
{
    uint    i, m, n = sizeof(BN)<<3;

    for (i = BN_SIZE; i-- > 0; n -= 32) {
        if ((m = pX->data[i]) || (i == 0)) break;
    }

    return (n -= 32 - GetWBits(m));
}


uint BN_isZero(const BN* pX)
{
    uint    i;

    for (i=0; i<BN_SIZE; i++) {
        if (pX->data[i]) return 0;
    }

    return 1;
}


uint BN_isOne(const BN* pX)
{
    uint    i;

    if (pX->data[0] ^ 1) return 0;    
    for (i=1; i<BN_SIZE; i++) {
        if (pX->data[i]) return 0;
    }

    return 1;
}


uint BN_isEven(const BN* pX)
{
    return ((pX->data[0] & 1) ^ 1);
}


uint BN_isEqual(const BN* pX, const BN* pY)
{
    uint    i;

    for (i=0; i < BN_SIZE; i++) {
        if (pX->data[i] ^ pY->data[i]) return 0;
    }

    return 1;
}


uint BN_isNotBigger(const BN* pX, const BN* pY)
{
    uint    i;

    for (i=BN_SIZE; i-- > 0; ) {
        if (pX->data[i] > pY->data[i]) return 0;
        else if (pX->data[i] < pY->data[i]) return 1;
    }

    return 1;
}


/******************************************************************************
* Function:     BN::ShiftW
*
* Description:  Shift right exactly s words.
*
* Returns:      
******************************************************************************/
uint BN_ShiftW(BN* pX, uint s)
{
    uint    i, n = 0;

    n = pX->data[s-1];
    for (i=0; s<BN_SIZE; i++, s++) {
        pX->data[i] = pX->data[s];
    }
    s -= i;
    for ( ; i<BN_SIZE; i++) {
        pX->data[i] = 0;
    }

    return n;
}


/******************************************************************************
* Function:     BN::ShiftR
*
* Description:  Shift right less than 32 and more than 0 bits
*
* Returns:      None
******************************************************************************/
void BN_ShiftR(BN* pX, uint b)
{
    uint    i;

    if ((b &= 31) == 0) return;

    for (i=0; i<BN_SIZE-1; i++) {
        pX->data[i] = (pX->data[i]>>b) | (pX->data[i+1]<<(32-b));
    }

    pX->data[i] >>= b;
}


/******************************************************************************
* Function:     BN_topOff
*
* Description:  Left sihft the BN until highest bit is 1. BN cannot be 0.
*
* Returns:      Number of bit position shifted.
******************************************************************************/
uint BN_topOff(BN* pX)
{
    uint    n = 0, i, j;

    if (pX->data[BN_SIZE-1] == 0) {
        for (i=j=BN_SIZE; j-- > 0; ) {
            if (pX->data[j]) {
                j++; break;
            }
            n += 32;
        }
        for ( ; j-- > 0; ) {
            pX->data[--i] = pX->data[j];
        }
        for ( ; i-- > 0; ) {
            pX->data[i] = 0;
        }
    }

    n += (BN_SIZE<<5) - BN_getBits(pX);

    if (n&31) {
        j = n&31;
        i = BN_SIZE;
        pX->data[--i] <<= j;
        for ( ; i-->0; ) {
            pX->data[i+1] |= pX->data[i] >> (32-j);
            pX->data[i] <<= j;
        }
    }

    return n;
}


/******************************************************************************
* Function:     BN_add
*
* Description:  Add one BN to another.
*
* Returns:      The carry flag. Zero if no carry over
******************************************************************************/
uint BN_add(BN* pR, const BN* pY)
{
    uint    i, d, iCarry = 0;

    for (i=0; i<BN_SIZE; i++) {
        pR->data[i] += (d = pY->data[i]) + iCarry;
        iCarry = (pR->data[i] < d) | ((pR->data[i] == d) & iCarry);
    }

    return iCarry;
}


/******************************************************************************
* Function:     BN_sub
*
* Description:  Subtract one BN from another.
*
* Returns:      The borrow flag. Zero if no borrow.
******************************************************************************/
uint BN_sub(BN* pR, const BN* pY)
{
    uint    i, a, iBorrow = 0;

    for (i=0; i<BN_SIZE; i++) {
        pR->data[i] = (a = pR->data[i]) - pY->data[i] - iBorrow;
        iBorrow = (a < pY->data[i]) | ((a == pY->data[i]) & iBorrow);
    }

    return iBorrow;
}


/******************************************************************************
* Function:     BN_sub2
*
* Description:  Subtract one BN from another BN and place the result to third BN
*
* Returns:      The borrow flag. Zero if no borrow.
******************************************************************************/
uint BN_sub2(const BN* pX, const BN* pY, BN* pR) {
    uint    i, a, iBorrow = 0;

    for (i=0; i<BN_SIZE; i++) {
        pR->data[i] = (a = pX->data[i]) - pY->data[i] - iBorrow;
        iBorrow = (a < pY->data[i]) | ((a == pY->data[i]) & iBorrow);
    }

    return iBorrow;
}


/******************************************************************************
* Function:     BN_iadd
*
* Description:  Add an unsigned 32 bits integer to BN.
*
* Returns:      None
******************************************************************************/
void BN_iadd(BN* pX, uint M) {
    uint    i, iCarry = M;

    for (i=0; (i<BN_SIZE) && iCarry; i++) {
        pX->data[i] += iCarry;
        iCarry = (pX->data[i] < iCarry);
    }
}


/******************************************************************************
* Function:     BN_isub
*
* Description:  Subtracting a 32 bits unsigned integer from BN
*
* Returns:      None
******************************************************************************/
void BN_isub(BN* pX, uint M)
{
    uint    i, a, iBorrow = M;

    for (i=0; (i<BN_SIZE) && iBorrow; i++) {
        pX->data[i] = (a = pX->data[i]) - iBorrow;
        iBorrow = (a < iBorrow);
    }
}


/******************************************************************************
* Function:     BN_mult
*
* Description:  Multiply two BN's and put the result in an array of two BN's
*
* Returns:      None
******************************************************************************/
void BN_mult(const BN* pX, const BN* pY, BN pR[2])
{
    uint        i, j, iCarry1, iCarry2;
    uint64_t    oneData;
    BN          add1, add2;

    BN_set(&(pR[0]), 0); BN_set(&(pR[1]), 0);
    for (i=0; i<BN_SIZE; i++) {
        for (j=0; j<BN_SIZE; j++) {
            oneData = (uint64_t)pX->data[i] * pY->data[j];
            add1.data[j] = ((U8*)&oneData)->u4.low;
            add2.data[j] = ((U8*)&oneData)->u4.high;
        }
        iCarry1 = iCarry2 = 0;
        for (j=0; j<BN_SIZE; j++) {
            pR->data[i+j]   += add1.data[j] + iCarry1;
            iCarry1 = (pR->data[i+j] < add1.data[j]) | ((pR->data[i+j] == add1.data[j]) & iCarry1);

            pR->data[i+j+1] += add2.data[j] + iCarry2;
            iCarry2 = (pR->data[i+j+1] < add2.data[j]) | ((pR->data[i+j+1] == add2.data[j]) & iCarry2);
        }
        for (; (j<(BN_SIZE+BN_SIZE)) && (iCarry1|iCarry2); j++) {
            pR->data[i+j]   += iCarry1;
            iCarry1 = ((pR->data[i+j] == 0) & iCarry1);

            pR->data[i+j+1] += iCarry2;
            iCarry2 = ((pR->data[i+j+1] == 0) & iCarry2);
        }
    }
}


/******************************************************************************
* Function:     BN_multW
*
* Description:  Multiply a BN by a 32 bits uint W. The result will be a BN plus
*               lowest 32 bits which is returned.
*
* Returns:      The lowest 32 bits of the result.
******************************************************************************/
uint BN_multW(const BN* pX, uint W, BN* pR)
{
    uint    i=0, n, c, r;
    U8      oneData;
    //BN      add1, add2;

    n = pX->data[0];
    oneData.u8 = (uint64_t)n * W;
    r = oneData.u4.low;

    for (i=1; i<BN_SIZE; i++)
    {
        n = pX->data[i];
        c = oneData.u4.high;
        oneData.u8 = (uint64_t)n * W;
        oneData.u4.low += c;
        oneData.u4.high += (oneData.u4.low < c);
        pR->data[i-1] = oneData.u4.low;
    }
    pR->data[i-1] = oneData.u4.high;

    return r;
}


/******************************************************************************
* Function:     BN_Random
*
* Description:  Generate a random BN number.
*
* Returns:      None
******************************************************************************/
void BN_Random(FRND pfRnd, BN* pR, uint nKeyBytes)
{
    uint i;
    for (i=0; i<(nKeyBytes>>2); i++) {
        pR->data[i] = pfRnd();
    }
    pR->data[i-1] |= 0xC0000000;
    pR->data[0]   |= 1;
    for ( ; i<BN_SIZE; i++) {
        pR->data[i] = 0;
    }
}


/******************************************************************************
* Function:     BN_multModR
*
* Description:  Calculate multiplication of two BN and then module against M
*               with the help of R. Result = (X*Y) mod M
*
* Returns:      None
******************************************************************************/
void BN_multModR
(
    const BN*   pX,
    const BN*   pY,
    const BN*   pM,
    const BN*   pR,
    BN*         pResult
)
{
    uint bit, bit0 = BN_getBits(pM);
    BN  M, R[2], Q[3];

    //To calculation (X*Y) mod M. Let R = X*Y. Note (1+pR) ~= 1/M. Result is
    //R - (R/M)*M = R - ((R*(1+pR))>>N)*M = R - (R>>N)*M - (((R>>N)*pR)>>N)*M
    //Finally The result is subtracted by M repeately until it's smaller.

    //R = X*Y
    M = *pM;
    bit = BN_topOff(&M);

    BN_mult(pX, pY, R);
    BN_mult(&(R[1]), pR, &(Q[1]));
    BN_mult(&(R[1]), &M, &(Q[0]));

    // R -= (R>>N)*M;
    BN_isub(&(R[1]), BN_sub(&(R[0]), &(Q[0])));
    BN_sub(&(R[1]), &(Q[1]));

    // S = ((R>>N)*pR)>>N) * M
    BN_mult(&(Q[2]), &M, &(Q[0]));

    // R -= S. Now R is not much bigger than M.
    BN_isub(&(R[1]), BN_sub(&(R[0]), &(Q[0])));
    BN_sub(&(R[1]), &(Q[1]));

    while (!BN_isZero(&(R[1]))) {
        BN_isub(&(R[1]), BN_sub(&(R[0]), &M));
    }

    while (BN_getBits(&(R[0])) >= bit0+3) {
        BN_mult(&(R[0]), pR, &(Q[0]));
        Q[0] = R[0];

        BN_ShiftW(&(Q[0]), bit0>>5);
        BN_ShiftW(&(Q[1]), bit0>>5);
        BN_ShiftR(&(Q[0]), bit0);
        BN_ShiftR(&(Q[1]), bit0);

        BN_add(&(Q[0]), &(Q[1]));
        BN_mult(&(Q[0]), pM, &(Q[1]));

        BN_sub(&(R[0]), &(Q[1]));
    }

    //Continue subtracting M until we get the modulo smaller than M.
    while (BN_isNotBigger(pM, &(R[0]))) {
        BN_sub(&(R[0]), pM);
    }

    *pResult = R[0];
}


/******************************************************************************
* Function:    BN_divide 
*
* Description:  Calculate one BN divided by another BN, with quote and remainder
*
* Returns:      None
******************************************************************************/
void BN_divide(const BN* pX, const BN* pM, BN* pQ, BN* pR)
{
    uint    bit;
    BN  R, Q, r, t, S[2];

    bit = BN_getBits(pM);

    BN_set(&Q, 0); r = *pX;
    BN_reverse(pM, &R);

    while (BN_isNotBigger(pM, &r)) {
        t = r;
        BN_ShiftW(&t, bit>>5);
        if (bit&31) {
            BN_ShiftR(&t, bit&31);
        }
        BN_mult(&t, &R, S);
        BN_add(&t, &(S[1]));

        if (BN_isZero(&t)) {
            BN_sub(&r, pM);
            BN_iadd(&Q, 1);
        } else {
            BN_mult(&t, pM, S);
            BN_sub(&r, &(S[0]));
            BN_add(&Q, &t);
        }
    }

    *pQ = Q;
    *pR = r;
}


/******************************************************************************
* Function:     BN_reverse
*
* Description:  Find R so that (2^N+R)*M ~= 2^(N + n) arithmatically.
*               N = LINT_BITS/2, n is number of bits of M. R should be
*               just slightly less than the precise theoretical number.
*
* Returns:      None
******************************************************************************/
void BN_reverse(const BN* pM, BN* pR)
{
    uint    bit = BN_getBits(pM);
    BN      M, C, D, R[2];

    M = *pM; BN_set(&C, 0);
    BN_topOff(&M);
    BN_sub(&C, &M);
    *pR = C;

    for (;;) {
        BN_mult(pR, &M, R);
        BN_sub2(&C, &(R[1]), &D);

        if (BN_isZero(&D)) {
            break;
        }

        BN_mult(&D, pR, R);
        BN_add(pR, &D);
        BN_add(pR, &(R[1]));
    }

    do {
        BN_isub(pR, 1);
        BN_mult(pR, &M, R);
        BN_sub2(&C, &(R[1]), &D);
    } while (BN_isZero(&D));
}


/******************************************************************************
* Function:     BN_MInverse
*
* Description:  Calculate modular reverse R = X^-1 mod M so (R*X) mod M = 1.
*               We use the Extended Euclidean Algorithm. M must be odd.
*
* Returns:      None
******************************************************************************/
void BN_MInverse(const BN* pX, const BN* pM, BN* pR)
{
    //Find R =X^-1 so that (X*R) mod M = 1
    uint    i, s, d1, d2, d3, d4;
    BN      f1, f2, q1, q2, R;

    BN_reverse(pM, &R);

    //Choose factor1 = 1 and factor 2 = M^-1. Calculator modulo
    //(f1*X) mod M and (f2*X) mod M, respectively.
    BN_set(&f1, 1);
    BN_multModR(&f1, pX, pM, &R, &q1);

    BN_divide(pM, &q1, &f2, &q2);

    BN_add(&f2, &f1); BN_sub2(&q1, &q2, &q2);

    for (;;) {
        BN* pAf; BN* pAq; BN* pBf; BN* pBq;

        //Knowing M is odd, if both factor and remainder is even,
        //we can reduce them by half, as we search for remainder = 1.

        if (BN_isNotBigger(&q2, &q1)) {
            pAf = &f1; pAq = &q1; pBf = &f2; pBq = &q2;
        } else {
            pAf = &f2; pAq = &q2; pBf = &f1; pBq = &q1;
        }

        d1 = BN_getBits(pAq); d2 = BN_getBits(pBq);
        d3 = BN_getBits(pAf); d4 = BN_getBits(pBf);

        if (d1 - d2 > 3) {
            BN  tmp = *pBf;
            s = (BN_SIZE<<5) - d4;
            if (s > (d1-d2-2)) s = d1 - d2 - 2;

            for (i=0; i<s; i++) {
                BN_add(&tmp, &tmp);
                
                BN_add(pBq, pBq);

                if (BN_isNotBigger(pM, &tmp)) {
                    BN_sub(&tmp, pM);
                }
            }

            if (BN_isNotBigger(&tmp, pAf)) {
                BN_sub(pAf, &tmp);
            } else {
                BN_add(pAf, pM);
                BN_sub(pAf, &tmp);
            }
            BN_sub(pAq, pBq);

            for (i=0; i<s; i++) {
                BN_ShiftR(pBq, 1);
            }
        }

        if (BN_isNotBigger(pBf, pAf)) {
            BN_sub(pAf, pBf);
        } else {
            BN_add(pAf, pM);
            BN_sub(pAf, pBf);
        }
        BN_sub(pAq, pBq);

        if (BN_isOne(pAq)) {
            if (BN_isNotBigger(pM, pAf)) {
                BN_sub(pAf, pM);
            }
            *pR = *pAf;

            break;
        }
    }
}


/******************************************************************************
* Function:     BN_MontMult
*
* Description:  Calculate the Montgomery Multiplication X*Y*R^-1 mod M
*
* Returns:      None.
******************************************************************************/
void BN_MontMult
(
    const BN*   pX,
    const BN*   pY,
    const BN*   pM,
    uint        w,
    BN*         pResult
)
{
    uint    i, C=0, d1, d2, r1, r2;
    BN      add1, add2, result;

    BN_set(&result, 0);

    d1 = (BN_getBits(pX)+31)>>5;
    d2 = (BN_getBits(pM)+31)>>5;

    for (i=0; i<d2; i++) {
        r2 = BN_ShiftW(&result, 1);
        result.data[BN_SIZE-1] = C;
        r1 = pY->data[i];
        r1 = BN_multW(pX, r1, &add1);

        C = BN_add(&result, &add1); r2 += r1;
        BN_iadd(&result, (r2<r1));

        r1 = BN_multW(pM, r2*w, &add2);

        C += BN_add(&result, &add2); r2 += r1;
        BN_iadd(&result, (r2<r1));
    }

    while (C || BN_isNotBigger(pM, &result)) {
        C -= BN_sub(&result, pM);
    }

    *pResult = result;
}


/******************************************************************************
* Function:     BN_ExpMod
*
* Description:  Calculate exponential multiplication and modulo. X^E mod M.
*
* Returns:      None
******************************************************************************/
void BN_ExpMod
(
    const BN*   pX,
    const BN*   pE,
    const BN*   pM,
    BN*         pResult
)
{
    uint    i, bit, n0 = GetN0(pM->data[0]);

    BN  X, R, Z;

    //First convert pX to Montgomery Representation.
    BN_set(&Z, 0);
    bit = BN_getBits(pM);
    if (bit < (BN_SIZE<<5)) {
        Z.data[(bit>>5)] |= 1<<(bit&31);
    }
    BN_sub(&Z, pM);

    BN_reverse(pM, &R);
    BN_multModR(pX, &Z, pM, &R, &Z);

    bit = BN_getBits(pE);

    n0 = n0;
    X = Z;
    for (i = bit-1; i-->0; ) {
        BN_MontMult(&X, &X, pM, n0, &X);

        if (pE->data[(i>>5)] & (1<<(i&31))) {
            BN_MontMult(&X, &Z, pM, n0, &X);
        }
    }

    // Convert the result from Montgomery Representation back to regular form.
    BN_set(&Z, 1);
    BN_MontMult(&X, &Z, pM, n0, pResult);
}


/******************************************************************************
* Function:     BN_RMTest
*
* Description:  Rabin-Miller primarity test.
*
* Returns:      None zero = pX is likely a prime. Zero = pX is NOT a prime.
******************************************************************************/
uint BN_RMTest(const BN* pX, uint testBase)
{
    uint    a = 0, j = 0;
    BN      B, PM1, M, R, Z;

    BN_set(&B, testBase);
    PM1 = *pX;

    BN_isub(&PM1, 1);
    M = PM1;

    while (BN_isEven(&M)) {
        a ++; BN_ShiftR(&M, 1);
    }

    BN_ExpMod(&B, &M, pX, &Z);
    if (BN_isOne(&Z) || BN_isEqual(&Z, &PM1)) {
        return 1;
    }

    BN_reverse(pX, &R);

    for (j = 1; j < a; j++) {
        BN_multModR(&Z, &Z, pX, &R, &Z);

        if (BN_isEqual(&Z, &PM1)) {return 1;}
        if (BN_isOne(&Z)) {return 0;}
    }

    return 0;
}


/******************************************************************************
* Function:     BN_Prime
*
* Description:  Search for a prime number of 1024 bits.
*
* Returns:      None
******************************************************************************/
void BN_Prime(FRND pfRnd, BN* P, uint nKeyBytes)
{
    uint        i = 0, w, b1=0, b2=0;
    uint        data;
    const STREE* pT;
    const uchar* p1;

    BN_Random(pfRnd, P, nKeyBytes);

    w = BN_modw(P, PRIME_CYCLE);
    BN_iadd(P, (PRIME_CYCLE-w+1));
    pT = gT; b1 = 0;
    p1 = gSearch1;

    for (;;) {
        if (b1 == 0) {
            data = *p1++;
        }
        pT = &(gT[(data&1)?pT->N1:pT->N0]);
        data >>= 1; b1++; b1 &= 7;
        if (pT->val == NODE_NEXT) continue;
        else if (pT->val == NODE_END) {
            p1 = gSearch1;
            pT = gT;
            b1 = 0;
            continue;
        }

        BN_iadd(P, (pT->val)<<1);
        if (BN_isPrime(P)) break;
    }
}

static uint gcd(uint a, uint b)
{
    while (a && b) {
        if (b > a) b -= (b / a)*a;
        else a -= (a / b)*b;
    }
    return (a + b);
}

/******************************************************************************
* Function:     BN_isPrime
*
* Description:  Determine if the BN is a prime number.
*
* Returns:      None zero if the input is a prime. Zero otherwise.
******************************************************************************/
uint BN_isPrime(const BN* P)
{
    uint        b2 = 0, s, d2;
    const STREE* pQ;
    const uchar* p2;

    if (gcd(BN_modw(P, PRIME_CYCLE), PRIME_CYCLE) != 1) return 0;

    //Do a small integer trial division
    s = 1; pQ = gT; b2 = 0;
    p2 = gSearch2;

    for (;;) {
        if ((b2 &= 7) == 0) {
            d2 = *p2++;
        }
        pQ = &(gT[(d2 & 1) ? pQ->N1 : pQ->N0]);
        d2 >>= 1; b2++; b2 &= 7;
        if (pQ->val == NODE_NEXT) continue;
        else if (pQ->val == NODE_END) {
            b2 = 0; break;
        }

        s += pQ->val << 1;
        if (BN_modw(P, s) == 0) return 0; // break;
    }

    //Found a possible prime candidate co-prime to all small primes.
    //Main primality tests here. 8 rounds of Rabin-Miller tests is sufficient
    {
        uint    testNum = 0, testVal = 0x24242212; //Magic number
        while (testVal) {
            testNum += testVal & 0x0F; testVal >>= 4;
            if (!BN_RMTest(P, testNum)) return 0;
        }
    }

    //We finally got a Prime. This is the only way out
    return 1;
}

/******************************************************************************
* Function:     BN_Text2Key
*
* Description:  Convert external data to internal data representation.
*
* Returns:      None
******************************************************************************/
void BN_Text2Key(const uchar* p, BN* pKey, uint nKeyBytes)
{
    uint    i;

    for (i = BN_SIZE;  i-- > (nKeyBytes>>2); ) {
        pKey->data[i]  = 0;
    }
    for (i=(nKeyBytes>>2); i-- > 0; ) {
        pKey->data[i]  = ((uint)(*p++))<<24;
        pKey->data[i] |= ((uint)(*p++))<<16;
        pKey->data[i] |= ((uint)(*p++))<<8;
        pKey->data[i] |= ((uint)(*p++));
    }
}


/******************************************************************************
* Function:     BN_Key2Text
*
* Description:  Convert internal data representation to external data.
*
* Returns:      None
******************************************************************************/
void BN_Key2Text(const BN* pKey, uchar* p, uint nKeyBytes)
{
    uint    i;

    for (i=(nKeyBytes>>2); i-- > 0; ) {
        *p++ = (pKey->data[i]>>24)&0xFF;
        *p++ = (pKey->data[i]>>16)&0xFF;
        *p++ = (pKey->data[i]>>8)&0xFF;
        *p++ = (pKey->data[i]  )&0xFF;
    }
}


/******************************************************************************
* Function:     BN_KeyGen
*
* Description:  Generate a RSA public/private keypair.
*
* Returns:      None
******************************************************************************/
void BN_KeyGen
(
    FRND    pfRnd,
    uint    nPubExp,
    uint    nKeyBytes,
    uchar*  pPubKey,
    uchar*  pPriKey
)
{
    BN  P, Q, E, RSAKeys[2];
#define PubKey  (RSAKeys[0])
#define PriKey  (RSAKeys[1])

    BN_Prime(pfRnd, &P, nKeyBytes>>1);
    BN_Prime(pfRnd, &Q, nKeyBytes>>1);

    //Calculate public key mj = (p-1)*(q-1)
    BN_mult(&P, &Q, &PubKey);

    BN_Key2Text(&PubKey, pPubKey, nKeyBytes);

    BN_sub(&PubKey, &P);
    BN_sub(&PubKey, &Q);
    BN_iadd(&PubKey, 1);

    BN_set(&E, nPubExp);

    //Calculate decryption exponent d.
    BN_MInverse(&E, &PubKey, &PriKey);

    BN_Key2Text(&PriKey, pPriKey, nKeyBytes);
#undef PriKey
#undef PubKey
}


/******************************************************************************
* Function:     BN_Encrypt
*
* Description:  RSA Encryption using public key and exponent.
*
* Returns:      None.
******************************************************************************/
void BN_Encrypt(uchar* pText, const uchar* pPubKey, uint nPubExp, uint nKeyBytes)
{
    BN      X, E, M, R;

    BN_set(&E, nPubExp);
    BN_Text2Key(pPubKey, &M, nKeyBytes);
    BN_Text2Key(pText,   &X, nKeyBytes);

    BN_ExpMod(&X, &E, &M, &R);

    BN_Key2Text(&R,   pText, nKeyBytes);
}


/******************************************************************************
* Function:     BN_Decrypt
*
* Description:  RSA Decryption using private key and exponent.
*
* Returns:      None.
******************************************************************************/
void BN_Decrypt(uchar* pText, const uchar* pPubKey, const uchar* pPriKey, uint nKeyBytes)
{
    BN      X, D, M, R;

    BN_Text2Key(pText,   &X, nKeyBytes);
    BN_Text2Key(pPubKey, &M, nKeyBytes);
    BN_Text2Key(pPriKey, &D, nKeyBytes);

    BN_ExpMod(&X, &D, &M, &R);

    BN_Key2Text(&R,   pText, nKeyBytes);
}

#include "cipher.h"

void SetRsa(RSA* pRsa)
{
    pRsa->RsaEncrypt = BN_Encrypt;
    pRsa->RsaDecrypt = BN_Decrypt;
}
